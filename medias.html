<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Медиа :3</title>
    <link rel="icon" type="image/x-icon" href="assets/icon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        
        #shader-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
        }
        
        /* Изображение Nikki */
        .nikki-image {
            position: fixed;
            left: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 700px;
            height: 700px;
            background-image: url('assets/mediaPage/nikki.jpg');
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            z-index: -1;
        }
        
        .button-container {
            position: fixed;
            bottom: 30px;
            right: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            z-index: 2;
            transform: scale(0.7);
            transform-origin: bottom right;
        }
        
        .link-button {
            padding: 15px 40px;
            text-decoration: none;
            border-radius: 30px;
            font-size: 1.2rem;
            transition: all 0.3s ease;
            min-width: 200px;
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.2);
        }
        
        .link-button:hover {
            background: rgba(76, 51, 64, 0.9);
            transform: translateY(-3px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        .button-container img {
            width: 150%;
            height: auto;
            transition: transform 0.3s ease;
            filter: drop-shadow(0 0 5px rgba(255, 105, 180, 0.8));
        }
        
        .link-button:hover img {
            transform: scale(1.1);
        }
        
        /* Стили для частиц */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -2;
            overflow: visible;
        }
        
        .particle {
            position: absolute;
            width: 40px;
            height: 40px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            opacity: 0;
            animation: floatParticle 20s linear forwards;
        }
        
        @keyframes floatParticle {
            0% {
                transform: translateX(100vw) translateY(var(--start-y)) rotate(0deg);
                opacity: 0;
            }
            5% {
                opacity: 0.8;
            }
            10% {
                opacity: 0.9;
            }
            80% {
                opacity: 0.9;
            }
            90% {
                opacity: 0.8;
            }
            100% {
                transform: translateX(-100px) translateY(var(--end-y)) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <canvas id="shader-canvas"></canvas>
    
    <!-- Изображение Nikki -->
    <div class="nikki-image"></div>
    
    <div class="particles-container" id="particles-container"></div>
    
    <div class="button-container">
        <a href="https://t.me/tampleOfTheVoid" class="link-button" target="_blank">
            <img src="assets/mediaPage/telega.png" alt="Telegram" />
        </a>
        <a href="https://www.youtube.com/@NikkiRemo" class="link-button" target="_blank">
            <img src="assets/mediaPage/youtube.png" alt="Youtube" />
        </a>
        <a href="https://discordapp.com/users/784128682461102080" class="link-button" target="_blank">
            <img src="assets/mediaPage/discord.png" alt="Discord" />
        </a>
    </div>

    <script>
        // Подготовка canvas и WebGL контекста
        const canvas = document.getElementById('shader-canvas');
        const gl = canvas.getContext('webgl');
        
        if (!gl) {
            alert('Ваш браузер не поддерживает WebGL.');
        }
        
        // Установка размеров canvas
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        
        // Вершинный шейдер
        const vertexShaderSource = `
            attribute vec2 a_position;
            void main() {
                gl_Position = vec4(a_position, 0.0, 1.0);
            }
        `;
        
        // Фрагментный шейдер
        const fragmentShaderSource = `
            precision highp float;
            
            uniform float iTime;
            uniform vec2 iResolution;
            
            #define t iTime*2.
            #define SIZE 30.
            
            #define col1 vec3(51, 25, 38)/255.
            #define col2 vec3(76, 51, 64)/255.
            
            vec2 ran(vec2 uv) {
                uv *= vec2(dot(uv,vec2(127.1,311.7)),dot(uv,vec2(227.1,521.7)) );
                return 1.0-fract(tan(cos(uv)*123.6)*3533.3)*fract(tan(cos(uv)*123.6)*3533.3);
            }
            
            vec2 pt(vec2 id) {
                return sin(t*(ran(id+.5)-0.5)+ran(id-20.1)*8.0)*0.5;
            }
            
            void main() {
                vec2 uv = (gl_FragCoord.xy-.5*iResolution.xy)/iResolution.x;
                vec2 off = iTime/vec2(50.,30.);
                uv += off;
                uv *= SIZE;
                
                vec2 gv = fract(uv)-.5;
                vec2 id = floor(uv);
                
                float mindist = 1e9;
                vec2 vorv;
                for(float i=-1.;i<=1.;i++) {
                    for(float j=-1.;j<=1.;j++) { 
                        vec2 offv = vec2(i,j);
                        float dist = length(gv+pt(id+offv)-offv);
                        if(dist<mindist){
                            mindist = dist;
                            vorv = (id+pt(id+offv)+offv)/SIZE-off;
                        }
                    }
                }
                
                vec3 col = mix(col1,col2,clamp(vorv.x*2.2+vorv.y,-1.,1.)*0.5+0.5);
                
                gl_FragColor = vec4(col,1.0);
            }
        `;
        
        // Компиляция шейдера
        function compileShader(gl, source, type) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Ошибка компиляции шейдера:', gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            
            return shader;
        }
        
        const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
        const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
        
        // Создание программы шейдеров
        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        
        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
            console.error('Ошибка линковки программы:', gl.getProgramInfoLog(program));
        }
        
        gl.useProgram(program);
        
        // Создание буфера вершин
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        const positions = [
            -1.0, -1.0,
            1.0, -1.0,
            -1.0, 1.0,
            1.0, 1.0,
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
        
        const positionAttributeLocation = gl.getAttribLocation(program, "a_position");
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 2, gl.FLOAT, false, 0, 0);
        
        // Получение uniform-переменных
        const iTimeLocation = gl.getUniformLocation(program, "iTime");
        const iResolutionLocation = gl.getUniformLocation(program, "iResolution");
        
        // Анимация WebGL
        let startTime = Date.now();
        
        function render() {
            const currentTime = (Date.now() - startTime) / 1000;
            
            gl.uniform1f(iTimeLocation, currentTime);
            gl.uniform2f(iResolutionLocation, canvas.width, canvas.height);
            
            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            
            requestAnimationFrame(render);
        }
        
        render();

        // Система частиц с сердцами
        const heartImages = [
            'assets/mainPage/harts/1.png',
            'assets/mainPage/harts/2.png',
            'assets/mainPage/harts/3.png',
            'assets/mainPage/harts/4.png'
        ];

        const particlesContainer = document.getElementById('particles-container');
        const activeParticles = new Set();

        function createParticle() {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Случайное сердце
            const randomHeart = heartImages[Math.floor(Math.random() * heartImages.length)];
            particle.style.backgroundImage = `url('${randomHeart}')`;
            
            // Случайная позиция по Y (избегаем области с изображением Nikki)
            let startY;
            const nikkiAreaTop = (window.innerHeight / 2) - 250;
            const nikkiAreaBottom = (window.innerHeight / 2) + 250;
            
            // Генерируем позицию вне области Nikki
            if (Math.random() > 0.5) {
                startY = Math.random() * (nikkiAreaTop - 100) + 50;
            } else {
                startY = Math.random() * (window.innerHeight - nikkiAreaBottom - 100) + nikkiAreaBottom + 50;
            }
            
            const endY = startY + (Math.random() - 0.5) * 100;
            
            particle.style.setProperty('--start-y', `${startY}px`);
            particle.style.setProperty('--end-y', `${endY}px`);
            
            // Случайный размер
            const size = 25 + Math.random() * 35;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Случайная скорость (медленнее для лучшего эффекта)
            const duration = 18 + Math.random() * 12;
            particle.style.animationDuration = `${duration}s`;
            
            // Явно устанавливаем начальную позицию
            particle.style.left = '0';
            particle.style.top = '0';
            
            particlesContainer.appendChild(particle);
            activeParticles.add(particle);
            
            // Удаление частицы после завершения анимации
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                    activeParticles.delete(particle);
                }
            }, duration * 1000);
        }

        // Создание частиц с интервалом
        function startParticles() {
            if (activeParticles.size < 15) { // Ограничиваем количество частиц
                createParticle();
            }
            setTimeout(startParticles, 600 + Math.random() * 900);
        }

        // Запуск системы частиц
        startParticles();

        // Обработка изменения размера окна
        window.addEventListener('resize', () => {
            // Очищаем все частицы при изменении размера окна
            particlesContainer.innerHTML = '';
            activeParticles.clear();
            startParticles();
        });
    </script>
</body>
</html>